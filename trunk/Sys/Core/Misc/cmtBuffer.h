//==============================================================================
//              Cooperative MultiTasking system
//                    CMT system
// By Alexander Sibilev
//==============================================================================

/*Буферы переменного размера. В отличие от стандартных библиотека, выполненных в виде
  шаблонов, эта библиотека выполнена в виде обычных классов в связи с настоятельным
  требованием "исключить использование шаблонов, поскольку последние воспринимаются
  на всеми embedded компиляторами". В результате, вместо одного шаблона на все случаи
  жизни, сделаны различные классы на эти самые различные случаи.
  */

#ifndef CMT_BUFFER_H
#define CMT_BUFFER_H

//! Буфер переменного размера с элементами uint32
class CmtBuffer32 {
    uint32 *mBuffer; //!< Собственно буфер
    uint32  mSize;   //!< Размер буфера
  public:
    
    //! Конструктор буфера
    /*! Создает буфер с заданным количеством элементов
      \param size количество элементов типа uint32 */
    CmtBuffer32( uint32 size = 0 );
    
    //! Деструктор. Освобождает память, занятую буфером
    ~CmtBuffer32() { if( mBuffer ) delete mBuffer; }
    
    //! Прямой доступ к буферу. С содержимым буфера разрешены любые операции кроме освобождения
    uint32* Buffer() { return mBuffer; }
    
    //! Текущий максимальный размер буфера.
    uint32  Size() const { return mSize; }
    
    //! Перераспределить память под буфер.
    /*! Перераспределяет память под буфер с новым размером. Причем перераспределение
      производится только если новый размер больше предыдущего. Сокращение размера
      буфера не производится.
      \param size новый размер буфера в элементах uint32
      \return истина, в случае успеха, или ложь если перераспределение завершилось неудачно,
      при этом буфер сохраняет прежний размер и содержимое */
    bool    Resize( uint32 size );
  };

//! Буфер переменного размера с элементами типа uint8.
/*! Буфер переменного размера с элементами типа uint8 реализован в виде буфера
  с элементами типа uint32 с преобразованием типов. Это сделано по двум причинам:
  во первых для сокращения программы (повторное использованием буфера uint32), во
  вторых для избегания проблем с выравниванием для некоторых процессоров */
class CmtBuffer8 {
    CmtBuffer32 mBuffer; //!< Собственно буфер. Реализован в виде буфера uint32.
  public:
    //! Конструктор буфера
    /*! Создает буфер с заданным количеством элементов
      \param size количество элементов типа uint8 */
    CmtBuffer8( uint32 size = 0 ) : mBuffer( (sizeof(uint32) - 1 + size) / sizeof(uint32) ) {}
    
    //! Деструктор. Освобождает память, занятую буфером
    ~CmtBuffer8() {}
    
    //! Прямой доступ к буферу. С содержимым буфера разрешены любые операции кроме освобождения
    uint8* Buffer() { return (uint8*)(mBuffer.Buffer()); }
    
    //! Содержимое буфера в виде строки
    char*  Str() { return (char*)(mBuffer.Buffer()); }
    
    //! Текущий максимальный размер буфера.
    uint32 Size() const { return mBuffer.Size() * sizeof(uint32); }
    
    //! Перераспределить память под буфер.
    /*! Перераспределяет память под буфер с новым размером. Причем перераспределение
      производится только если новый размер больше предыдущего. Сокращение размера
      буфера не производится.
      \param size новый размер буфера в элементах uint32
      \return истина, в случае успеха, или ложь если перераспределение завершилось неудачно,
      при этом буфер сохраняет прежний размер и содержимое */
    bool   Resize( uint32 size ) { return mBuffer.Resize( (sizeof(uint32) - 1 + size) / sizeof(uint32) ); }
  };
#endif
