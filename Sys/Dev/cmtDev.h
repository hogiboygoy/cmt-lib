//==============================================================================
//              Cooperative MultiTasking system
//                    CMT system
// By Alexander Sibilev
//==============================================================================

#define CMT_DEV_BUSY    0
#define CMT_DEV_FREE    1
#define CMT_DEV_FAILURE 3

struct CmtDev;

//! Aбстрактное устройство.

//! Абстрактное устройство поддерживающее автоматический менеджемент и счетчик ссылок.
/*! Выполняет две функции:
- Обеспечивает доступ к устройству единственному потребителю (через механизм семафора)
- Обеспечивает поддержание счетчика ссылок, который блокирует удаление устройства, пока на
него есть ссылки и автоматически удаляет устройство, когда счетчик ссылок обнуляется.
Доступ: устройство может быть свободно, занято и недоступно. Этими состояниями управляет семафор.
Когда устройство свободно, его можно занять вызовом Lock. Освобождение свободного устройства делает его
недоступным. Занятое устройство можно освободить вызовом UnLock. Попытка занять уже занятое устройство
приводит к ожиданию его освобождения с последующим занятием. */
struct CmtDev : public CmtObject {
    CmtDev(); //!< Конструктор устанавливает счетчик ссылок в 1 и помечает устройство свободным
    virtual ~CmtDev() {} //!< Деструктор для определения специфичных действий
    
#ifdef CMT_DEV_ARBITR
  int32         mRefCount;   //!< Счетчик ссылок
  uint32        mSemaphore;  //!< Семафор менеджемента устройства
  
  void     AddRef(); //!< Увеличить счетчик ссылок
  void     DecRef(); //!< Уменьшить счетчик ссылок. При достижении нуля устройство удаляется
  uint_8   Lock();   //!< Блокировка устройства. Дает индивидуальный доступ к устройству. \return 1 когда устройство успешно занято, 0 когда устройство не доступно.
  void     UnLock(); //!< Разблокировка устройства. Дает остальным получить доступ к устройству
#endif
  };

//! Макроопределения для одобства работы
#ifdef CMT_DEV_ARBITR
  #define devLock()        Lock()
  #define checkLock( ret ) if( !Lock() ) return ret
  #define devUnLock()      UnLock()
  #define CLOCK(x)         (x)->Lock()
  #define CCHLOCK(x,ret)   if( !(x)->Lock() ) return ret
  #define CUNLOCK(x)       (x)->UnLock()
  #define CADDREF(x)       (x)->AddRef()
  #define CDECREF(x)       (x)->DecRef()
#else
  #define devLock()   
  #define checkLock( ret )
  #define devUnLock() 
  #define CLOCK(x)
  #define CCHLOCK(x,ret)
  #define CUNLOCK(x)
  #define CADDREF(x)
  #define CDECREF(x)
#endif

//! Абстрактный механизм менеджемента устройств.
/*! Поддерживает автоматическое подключение и отключение. Идея состоит в формировании списка менеджеров устройств.
  Имеется также задача менеджемента. Эта задача периодически с периодом 200 тиков производит проход по списку
  с вызовом для каждого элемента списка функции опроса Poll. Для управления списком служат функции добавления и 
  удаления из списка. Эти функции безопасны и позволяют вызов из собственной функции опроса для себя или любого другого
  устройства в списке. При этом обеспечивается корректное удаление из списка или добавление в него. */
struct CmtDevPolling : public CmtDev {
  CmtDevPolling *mNext; //!< Следующее устройство в списке
  
  //! Менеджемент (проверка) устройства
  virtual void Poll() = 0;

  //! Добавление слота к списку опрашиваемых устройств
  void AddPoll();
  
  //! Удаление слота из списка опрашиваемых устройств
  void RemovePoll();
  
  static CmtDevPolling *rootDev;
  static CmtDevPolling *nextPoll;
  };

typedef CmtDevPolling *CmtDevPollingPtr;

//! Задача менеджемента устройств
void cmtPollingDeviceTask();

//! Управление процессом передачи (прерывания, DMA, сопроцессор и пр.)
struct CmtTransfer : public CmtDev {
    //! Инициировать обмен
    /*! Настраивает обмен в соответствии с заданными параметрами и разрешает
      работу приемо-передатчика (приемо-передатчик входит в режим ожидания запроса)
      \param adr адрес обмена (источник или приемник, в зависимости от конфигурации канала)
      \param elemCount количество элементов во фрейме
      \param frameCount количество фреймов */
    virtual void   InitTransfer( void *adr, uint32 elemCount, uint32 frameCount ) = 0;

    //! Ожидает завершения обмена
    /*! Ожидает завершения обмена с возможностью прекращения ожидания.
      \param pBreak указатель на событие, обеспечивающее прекращение ожидания. Возможен нулевой указатель,
      если прекращение ожидания не требуется.
      \return код ошибки, отражающий состояние завершенной операции */
    virtual uint_8 WaitTransfer( CmtEvent *pBreak = 0 ) = 0;

    //! Прекращение обмена
    /*! Прекращает операцию. После этого вызова возможно повторное инициирование операции.*/
    virtual void   StopTransfer() = 0;

  };
